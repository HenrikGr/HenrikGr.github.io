{"componentChunkName":"component---src-templates-article-page-template-js","path":"/articles/typescript-value-object-explained/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Value object - a Typescript implementation","subtitle":"Implementation details of a value object in Typescript","date":"2021-03-02","publishedBy":"Henrik Grönvall"},"excerpt":"I regained the desire, drive and enthusiasm about a month ago and threw myself into getting acquainted \nwith Domain Driven Design and Typescript. It has been a…","timeToRead":9,"html":"<p>I regained the desire, drive and enthusiasm about a month ago and threw myself into getting acquainted\nwith Domain Driven Design and Typescript. It has been a very educational period where I not only got back\nthe architectural thinking and mentality but also started to like Typescript.</p>\n<h1>Typescript - implementation of a value object</h1>\n<p>I'm not going into if you should use Typescript or not in this article. There are pros- and cons about\nusing it which this article will not cover. This article will on the other hand go through some basic\nunderstanding of Typescript (and JavaScript) in order to understand my implementation of value object I'm\nusing in my \"research\" of Domain-Driven Design.</p>\n<h2>Typescript basics</h2>\n<p>First we need to understand some basic about Typescript interface definitions and common data types in both\nTypescript and JavaScript.</p>\n<p>We start with a simple Typescript example;</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Square</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">with</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span>      <span class=\"token comment\">// Required declaration</span>\n  color<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>    <span class=\"token comment\">// Optional decalaration</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">createSquare</span><span class=\"token punctuation\">(</span>config<span class=\"token operator\">:</span> Square<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> newSquare <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    width<span class=\"token operator\">:</span> config<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span>\n    color<span class=\"token operator\">:</span> config<span class=\"token punctuation\">.</span>color <span class=\"token operator\">?</span> config<span class=\"token punctuation\">.</span>color <span class=\"token operator\">:</span> <span class=\"token string\">'default'</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>In this simple example, we can see how we use required and optional properties for a square interface where\nthe width property is required but not the color property.</p>\n<p>Interfaces with optional properties are written similar to other interfaces, with each optional property\ndenoted by a (?) at the end of the property name in the declaration.</p>\n<p>These optional properties are popular when creating patterns like “option bags” where you pass an object to a\nfunction that only has a couple of properties filled in.</p>\n<p>In TypeScript, interfaces can also describe indexable types i.e. the types which can be accessed via indexes.\nIndexable types have an index signature that describes the types we can use to index into the object, along\nwith the corresponding return types when indexing. Let’s take an example:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">ObjectDictionary</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>index<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> myDict<span class=\"token operator\">:</span> ObjectDictionary <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'Henrik'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> myOtherDict<span class=\"token operator\">:</span> ObjectDictionary <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token string\">'username'</span><span class=\"token operator\">:</span> <span class=\"token string\">'Henrik'</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> myStrValueDict<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> myObjDict<span class=\"token punctuation\">.</span>name\n<span class=\"token keyword\">let</span> myStrValueOtherDict<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> myObjDict<span class=\"token punctuation\">[</span><span class=\"token string\">'username'</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Above, we have a ObjectDictionary interface that is an indexable interface with an index signature. This\nindex signature states that an ObjectDictionary is indexed with a string, and will return a string.</p>\n<p>The code above works since objects in JavaScript can be thought of as a dictionary. They can take arbitrary\nproperties (keys), which map to corresponding values. This object - dictionary duality is also visible in\nJavaScript syntax:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> myObject <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'Henrik'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> keyValue <span class=\"token operator\">=</span> myObject<span class=\"token punctuation\">[</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">const</span> keyValue2 <span class=\"token operator\">=</span> myObjetc<span class=\"token punctuation\">.</span>name</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>We could also see that the naming of the property for the indexable interface did not matter, we named it\n\"name\" in the first occasion and \"username\" in the other.</p>\n<p>To enforce naming of properties of the indexable interface, we can add them to the indexable interface;</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">ObjectDictionary</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>index<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n  username<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token comment\">// Returns the same type as the index signature</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> myObjDict<span class=\"token operator\">:</span> ObjectDictionary <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'Henrik'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//  Fails: Property 'username' is missing in type '{ name: string; }' </span>\n<span class=\"token comment\">//  but required in type 'ObjectDictionary'.</span>\n\n<span class=\"token keyword\">let</span> myDict<span class=\"token operator\">:</span> ObjectDictionary <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> username<span class=\"token operator\">:</span> <span class=\"token string\">'Henrik'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// Works</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Here we added a known property called username to the indexable interface which should be of type string.\nIt is valid since it returns the same type as the indexable type. The username property is a way for us to name the\nproperty in advance before using it. This also means we can not use other names of the indexable property.</p>\n<p>It is important to understand that properties can be added and removed in runtime and in general,\nmost objects have a constant known set of properties, and you model them as regular interfaces in Typescript.</p>\n<p>We need to use an indexable type if we want to model objects which follow JavaScript rules such as;</p>\n<ul>\n<li>can contain any property,</li>\n<li>can be modified in runtime by adding and deleting properties.</li>\n</ul>\n<p>Note that there are 2 common kinds of indices in JavaScript;</p>\n<ul>\n<li>number - you can only index via a number (which means you use them like an array)</li>\n<li>string - you can index via any string (you use them like a dictionary)</li>\n</ul>\n<h2>Typescript generics</h2>\n<p>A major part of software engineering is building components that not only have well-defined and consistent\nAPIs, but are also reusable. Components that are capable of working on the data of today as well as the\ndata of tomorrow will give you the most flexible capabilities for building up large software systems.</p>\n<p>In languages like C# and Java, one of the main tools in the toolbox for creating reusable components is\ngenerics, that is, being able to create a component that can work over a variety of types rather than a\nsingle one. This allows users to consume these components and use their own types.</p>\n<p>To start off, let’s do the “hello world” of generics: the value function. The value function is a\nfunction that will return whatever is passed in. You can think of this as the echo command.</p>\n<p>Without generics, we would either have to give the value function a specific type:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span>arg<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> arg<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>Or, we could describe the value function using the any type:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span>arg<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">any</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> arg\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>A quick note about the any type in Typescript:\nIn some situations, not all type information is available or its declaration would take an inappropriate amount\nof effort. These may occur for values from code that has been written without TypeScript or a 3rd party library.\nIn these cases, we might want to opt-out of type checking. To do so, we label these values with the any type:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span>key<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">any</span>\n<span class=\"token comment\">// OK, return value of 'getValue' is not checked</span>\n<span class=\"token keyword\">const</span> str<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> <span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"myString\"</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>The any type is a powerful way to work with existing JavaScript, allowing you to gradually opt-in and opt-out\nof type checking during compilation.</p>\n<p>Back to generics: While using any is certainly generic in that it will cause the function to accept any and\nall types for the type of arg, we actually are losing the information about what that type was when the\nfunction returns. If we passed in a number, the only information we have is that any type could be returned.</p>\n<p>Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote\nwhat is being returned. Here, we will use a type variable, a special kind of variable that works on types\nrather than values.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">value</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>arg<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> arg\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>We’ve now added a type variable T to the value function. This T allows us to capture the type the user\nprovides (e.g. number), so that we can use that information later. Here, we use T again as the return type.\nOn inspection, we can now see the same type is used for the argument and the return type. This allows us to\ntraffic that type information in one side of the function and out the other.</p>\n<p>We say that this version of the value function is generic, as it works over a range of types. Unlike using\nany, it’s also just as precise (ie, it does not lose any information) as the first value function that used\nnumbers for the argument and return type.</p>\n<p>Once we’ve written the generic value function, we can call it in one of two ways. The first way is to pass\nall arguments, including the type argument, to the function:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">let</span> output <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">value</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token string\">\"myString\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//                 ^ = let output: string</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>Here we explicitly set the type variable T to be string as one of the arguments to the function call, denoted\nusing the &#x3C;> around the arguments rather than ().</p>\n<p>The second way is also perhaps the most common. Here we use type argument inference — that is, we want the\ncompiler to set the value of the type variable T for us automatically based on the type of the argument we\npass in:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">let</span> output <span class=\"token operator\">=</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"myString\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//    ^ = let output: string</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>Notice that we did not have to explicitly pass the type in the angle brackets (&#x3C;>); the compiler just looked\nat the value \"myString\", and set the type variable T to its type. While type argument inference can be a\nhelpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments\nas we did in the previous example when the compiler fails to infer the type, as may happen in more complex\nexample.</p>\n<p>Now it's time to head over to my implementation of the value object.</p>\n<h2>Implementation of a value object</h2>\n<p>My implementation of the value object I'm using in my journey to learn more about Domain-Driven Design took\nsome time for me to create since I needed to understand the basics about Typescript.</p>\n<p>The value object implementation:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">IValueObjectProps</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>index<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">any</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ValueObject<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> IValueObjectProps<span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> props<span class=\"token operator\">:</span> <span class=\"token constant\">T</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token operator\">...</span>props<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>As the name indicate I'm using it for objects and that means it can be viewed as a dictionary type.\nRemember objects in JavaScript can take arbitrary properties, which map to corresponding values</p>\n<p>The value objects own properties (props) interface (IValueObjectProps) is an indexable interface returning\nthe type any.</p>\n<p>The class own properties (props) has been declared as a generic type, and the properties (props) passed into\nthe constructor has also been declared as generic type. </p>\n<p>The class itself has been declared as an abstract class and abstract classes are base classes from which other\nclasses may be derived. They may not be instantiated directly. Unlike an interface, an abstract class may\ncontain implementation details for its members.</p>\n<p>How do I used it?</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">ValueObjectProps</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>index<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">any</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ValueObject<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> ValueObjectProps<span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">protected</span> props<span class=\"token operator\">:</span> <span class=\"token constant\">T</span>\n  <span class=\"token keyword\">protected</span> <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token operator\">...</span>props<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">UserNameProps</span> <span class=\"token punctuation\">{</span>\n  username<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">UserName</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ValueObject<span class=\"token operator\">&lt;</span>UserNameProps<span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> UserNameProps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token keyword\">get</span> <span class=\"token function\">Value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token keyword\">get</span> <span class=\"token function\">username</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>username\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> vo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> username<span class=\"token operator\">:</span> <span class=\"token string\">'Henrik'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> vo<span class=\"token punctuation\">.</span>Value\n<span class=\"token keyword\">let</span> username <span class=\"token operator\">=</span> vo<span class=\"token punctuation\">.</span>username\n\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>vo<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//  UserName { props: { username: 'Henrik' } }</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// { username: 'Henrik' }</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// Henrik</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>First, we can see the UserName class inherits from the abstract class ValueObject, and we passed the UserName\nown property interface (UserNameProps) to the type variable T in the ValueObject class. The type variable T\nextends the value objects onw properties (ValueObjectProps), which consist of an indexable signature and\nreturns any type. You can think about it that we have now named the allowed properties to the value object own\nproperty interface. The allowed property name is now username for the ValueObjects indexable interface.</p>\n<p>The parameters to the constructor of the UserName class accepts only the declaration of its own interface\n(UserNameProps) which also only accept a property named username with a return type of string.</p>\n<p>When we instantiate a new UserName object, the actual value is stored in the ValueObject own properties\n(props) which can be accessed by getter or setter methods in the UserName instance. Now it is up to the\ndeveloper to design getters and setters for the value object they create.</p>\n<p>Note that I have declared the constructor of the value object as protected and thus it is only available\nfor derived classes. I have also left out the equality comparison method implemented in the ValueObject class.\nIn Domain-Driven Design value object are treated as equal by their value of the properties.</p>\n<p>Another design issue I have not decided on is if the value objects own properties should be declared\nprotected or public. If they are protected, the derived class must implement getters and setters for all\nof them, if they are declared public the developer can access them without getters or setters. </p>\n<p>Here is why I like the indexable types and its power. A pure bonus:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// Defining reusable indexable type</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">States</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>state<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> moodStates<span class=\"token operator\">:</span> States <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'isHungry'</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'mustCookFood'</span><span class=\"token operator\">:</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>moodStates<span class=\"token punctuation\">.</span>isHungry<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>moodStates<span class=\"token punctuation\">.</span>mustCookFood<span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// false</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2>Summary</h2>\n<p>That's all for now, I'm not an expert of Typescript, I think it has some nice features, I like especially\nthe ide of coding against an interface and using interfaces for dependency injection. </p>\n<p>References:</p>\n<ul>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/\">Typescript Handbook</a></li>\n</ul>"}},"pageContext":{"slug":"/articles/typescript-value-object-explained/"}},"staticQueryHashes":["4011214723"]}