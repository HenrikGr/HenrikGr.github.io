{
    "componentChunkName": "component---src-templates-article-page-template-js",
    "path": "/articles/node-http-secorutiy/",
    "result": {"data":{"markdownRemark":{"frontmatter":{"title":"Web application security with CORS and CSP","subtitle":"Improve your app security with CORS and CSP","date":"2021-04-30","publishedBy":"Henrik Grönvall"},"excerpt":"Cross Origin Resource Sharing (CORS) and Content Security Policy (CSP) are HTTP response headers which when implemented\nhelp to improve the security of a web…","timeToRead":22,"html":"<p>Cross Origin Resource Sharing (CORS) and Content Security Policy (CSP) are HTTP response headers which when implemented\nhelp to improve the security of a web application. Both security headers allow application owners to whitelist the\norigin of resources in their web application. Both seems to work the same but there are differences.</p>\n<p>To understand Cross Origin Resource Sharing (CORS) and Content Security Policy (CSP) headers we need to understand\n<em>SameOriginPolicy</em> first.</p>\n<h2>Same-origin policy</h2>\n<p>The same-origin policy is a browser security feature that restricts how documents and scripts on one origin can interact\nwith resources on another origin.</p>\n<p>An origin is defined by the scheme (also known as the protocol, for example HTTP or HTTPS), port (if it is specified),\nand host. When all three are the same for two URLs, they are considered same-origin.</p>\n<p>For example, <a href=\"http://example.com:5000/foo\">http://example.com:5000/foo</a> is the same origin as <a href=\"http://example.com:5000/bar\">http://example.com:5000/bar</a> but not\n<a href=\"https://example.com:5000/status\">https://example.com:5000/status</a> because the scheme is different.</p>\n<h3>What is permitted and blocked by the same-origin policy</h3>\n<p>A browser can load and display resources from multiple sites at once. You might have multiple tabs open at the same time,\nor a site could embed multiple iframes from different sites. If there is no restriction on interactions between these\nresources, and a script is compromised by an attacker, the script could expose everything in a user's browser.</p>\n<p>The same-origin policy controls interactions between two different origins. These interactions are typically placed\ninto three categories:</p>\n<ol>\n<li>Cross-origin writes are typically allowed.\nExamples are links, redirects, and form submissions.\nSome HTTP requests require preflight.</li>\n<li>Cross-origin embedding is typically allowed.</li>\n<li>Cross-origin reads are typically disallowed, but read access is often leaked by embedding.\nFor example, you can read the dimensions of an embedded image, the actions of an embedded script, or the availability\nof an embedded resource.</li>\n</ol>\n<p>The same-origin policy has some historical exceptions as you can see and if the web could be designed from scratch, these\nexceptions wouldn't exist. Unfortunately, by the time the web community realized the key benefits of a strict same-origin\npolicy, the web was already relying on these exceptions.</p>\n<h2>Cross Origin Resource Sharing (CORS)</h2>\n<p>Cross-Origin Resource Sharing (CORS) is a protocol that enables scripts running on a browser client to interact with\nresources from a different origin. This is useful because, thanks to the same-origin policy followed by XMLHttpRequest\nand Fetch API, JavaScript can only make calls to URLs that live on the same origin as the location where the script\nis running.</p>\n<p>Most of the time, a script running in the user's browser would only ever need to access resources on the same origin\n(think about API calls to the same backend that served the JavaScript code in the first place). So the fact that\nJavaScript can't normally access resources on other origins is a good thing for security.</p>\n<p>However, there are legitimate scenarios where cross-origin access is desirable or even necessary. For example, if you're\nrunning a React SPA that makes requests to an API backend running on a different origins.</p>\n<p>On the server side, when a server has been configured correctly to allow cross-origin resource sharing, some special\nheaders will be included. Their presence can be used to determine that a request supports CORS. Web browsers can use\nthese headers to determine whether a request call should continue or fail.</p>\n<p>There are a few headers that can be set, but the primary one that determines who can access a resource is\nAccess-Control-Allow-Origin. This header specifies which origins can access the resource. For example, to allow access\nfrom any origin, you can set the response header as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Access-Control-Allow-Origin: *</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Or it can be narrowed down to a specific origin:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Access-Control-Allow-Origin: https://example.com</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>CORS is normally used for \"anonymous requests\" where the request does not identify the requester. If you want to send\ncookies (which could identify the sender) using for example the Fetch API, you need to add additional headers to the\nrequest and response.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://example.com'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">mode</span><span class=\"token operator\">:</span> <span class=\"token string\">'cors'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">credentials</span><span class=\"token operator\">:</span> <span class=\"token string\">'include'</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The response headers from the server should now look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">HTTP/1.1 200 OK\nAccess-Control-Allow-Origin: https://example.com\nAccess-Control-Allow-Credentials: true</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>Note: The Access-Control-Allow-Origin should have an origin set in the response header, and the\nAccess-Control-Allow-Credentials should be set to true.</p>\n<h3>Understanding CORS request types</h3>\n<p>There are two types of CORS request: \"simple\" requests and \"preflight\" requests. It's the browser that determines\nwhich is used. As the developer, you don't normally need to care about this when you are constructing requests to be\nsent to a server. However, you may see the different types of requests appear in your network log, and since it may have\na performance impact on your application it may benefit you to know why and when these requests are sent.</p>\n<p>The browser deems the request to be a \"simple\" request when the request itself meets a certain set of requirements:</p>\n<ul>\n<li>One of these methods is used: GET, POST, or HEAD.</li>\n<li>A CORS safe-listed header is used.</li>\n<li>When using the Content-Type header, only the following values are allowed: application/x-www-form-urlencoded, multipart/form-data, or text/plain.</li>\n<li>No event listeners are registered on any XMLHttpRequestUpload object.</li>\n<li>No ReadableStream object is used in the request.</li>\n</ul>\n<p>The request is allowed to continue as normal if it meets these criteria, and the Access-Control-Allow-Origin header is\nchecked when the response is returned.</p>\n<p>If a request does not meet the criteria for a \"simple\" request, the browser will instead make an automatic preflight\nrequest using the OPTIONS method. This call is used to determine the exact CORS capabilities of the server, which is\nin turn used to determine whether the intended CORS protocol is understood. If the result of the OPTIONS call\ndictates that the request cannot be made, the actual request to the server will not be executed.</p>\n<p>The preflight request sets the mode as OPTIONS and sets a couple of headers to describe the actual request that\nis to follow:</p>\n<ul>\n<li>Access-Control-Request-Method: The intended method of the request (e.g., GET or POST).</li>\n<li>Access-Control-Request-Headers: An indication of the custom headers that will be sent with the request.</li>\n<li>Origin: The usual origin header that contains the script's current origin.</li>\n</ul>\n<p>An example of such a request might look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">OPTIONS /data HTTP/1.1\nOrigin: https://example.com\nAccess-Control-Request-Method: DELETE\nAccess-Control-Request-Headers: Content-Type, Accept</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>This request basically says, I would like to make a DELETE request with the Content-Type and Accept headers on\n<a href=\"https://example.com\">https://example.com</a> - is that possible?</p>\n<p>The server will include some Access-Control-* headers within the response to indicate whether the request that follows\nwill be allowed or not. These include:</p>\n<ul>\n<li>Access-Control-Allow-Origin: The origin that is allowed to make the request, or * if a request can be made from any origin.</li>\n<li>Access-Control-Allow-Methods: A comma-separated list of HTTP methods that are allowed.</li>\n<li>Access-Control-Allow-Headers: A comma-separated list of the custom headers that are allowed to be sent.</li>\n<li>Access-Control-Max-Age: The maximum duration that the response to the preflight request can be cached before another call is made.</li>\n</ul>\n<p>A response to the earlier example might look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">HTTP/1.1 200 OK\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE\nAccess-Control-Allow-Headers: Content-Type, Accept\nAccess-Control-Max-Age: 120\nVary: Access-Control-Request-Headers\nContent-Length: 0\nConnection: keep-alive</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The response would then be examined by the browser to decide whether to continue with the request or to abandon it.</p>\n<p>The Access-Control-Allow-Origin header, in this case, allows the request to be made from any origin, while the\nAccess-Control-Allow-Methods header describes only the accepted HTTP methods. If a given HTTP method is not accepted,\nit will not appear in this list.</p>\n<p>In this example, Access-Control-Allow-Headers echos back the headers that were asked for in the OPTIONS request.\nThis indicates that all the requested headers are allowed to be sent. If for example, the server doesn't allow the\nAccept header, then that header would be omitted from the response, and the browser would reject the call.</p>\n<h2>Content Security Policy (CSP)</h2>\n<p>Content Security Policy (CSP) header is used to define what content can run on its own domain. It is an added layer of\nsecurity that helps to detect and mitigate certain types of attacks, including Cross Site Scripting (XSS) and data\ninjection attacks. These attacks are used for everything from data theft to site defacement to distribution of malware.</p>\n<p>To enable CSP, you need to configure your web server to return the Content-Security-Policy HTTP header.</p>\n<p>Alternatively, the <meta> element can be used to configure a policy, for example:\n<meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; img-src https://*; child-src 'none';\"></p>\n<p>By injecting the Content-Security-Policy (CSP) headers from the server, the browser is aware and capable of protecting\nthe user from dynamic calls that will load content into the page currently being visited.</p>\n<h3>Mitigating cross site scripting</h3>\n<p>A primary goal of CSP is to mitigate and report XSS attacks. XSS attacks exploit the browser's trust of the content\nreceived from the server. Malicious scripts are executed by the victim's browser because the browser trusts the source\nof the content, even when it's not coming from where it seems to be coming from.</p>\n<p>CSP makes it possible for server administrators to reduce or eliminate the vectors by which XSS can occur by specifying\nthe domains that the browser should consider to be valid sources of executable scripts. A CSP compatible browser will\nthen only execute scripts loaded in source files received from those allowlisted domains, ignoring all other script\n(including inline scripts and event-handling HTML attributes).</p>\n<p>As an ultimate form of protection, sites that want to never allow scripts to be executed can opt to globally disallow\nscript execution.</p>\n<h3>Mitigating packet sniffing attacks</h3>\n<p>In addition to restricting the domains from which content can be loaded, the server can specify which protocols are\nallowed to be used; for example (and ideally, from a security standpoint), a server can specify that all content must\nbe loaded using HTTPS. A complete data transmission security strategy includes not only enforcing HTTPS for data\ntransfer, but also marking all cookies with the secure attribute and providing automatic redirects from HTTP pages to\ntheir HTTPS counterparts. Sites may also use the Strict-Transport-Security HTTP header to ensure that browsers connect\nto them only over an encrypted channel.</p>\n<h3>Configure your CSP policy</h3>\n<p>Configuring Content Security Policy involves adding the Content-Security-Policy HTTP header to a web page and giving it\nvalues to control what resources the user agent is allowed to load for that page. For example, a page that uploads and\ndisplays images could allow images from anywhere, but restrict a form action to a specific endpoint. A properly designed\nContent Security Policy helps protect a page against a cross site scripting attack.</p>\n<p>You can use the Content-Security-Policy HTTP header to specify your policy, like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Content-Security-Policy: policy</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>A policy is described using a series of policy directives, each of which describes the policy for a certain resource\ntype or policy area. Your policy should include a default-src policy directive, which is a fallback for other resource\ntypes when they don't have policies of their own (for a complete list, see the description of the default-src directive).</p>\n<p>A policy needs to include a default-src or script-src directive to prevent inline scripts from running, as well as\nblocking the use of eval().</p>\n<p>A policy needs to include a default-src or style-src directive to restrict inline styles from being applied from a\n<code class=\"language-text\">&lt;style></code> element, or a style attribute.</p>\n<p>There are specific directives for a wide variety of types of items, so that each type can have its own policy, including\nfonts, frames, images, audio and video media, scripts, and workers.</p>\n<h2>Recommended measures for CSP</h2>\n<p><a href=\"https://owasp.org/www-community/xss-filter-evasion-cheatsheet\">The XSS Cheat Sheet</a> is an old but representative\ncross-section of the methods an attacker might use to violate this trust by injecting malicious code. If an attacker\nsuccessfully injects any code at all, it's pretty much game over: user session data is compromised and information\nthat should be kept secret is exfiltrated.</p>\n<p>The following overview highlights a defense that can significantly reduce the risk and impact of XSS attacks in modern\nbrowsers.</p>\n<h3>Source allow list</h3>\n<p>The issue exploited by XSS attacks is the browser's inability to distinguish between script that's part of your\napplication and script that's been maliciously injected by a third party.</p>\n<p>For example, if you trust some API to deliver valid code, you should define a policy that only allows script to execute\nwhen it comes from the trusted sources:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Content-Security-Policy: script-src 'self' https://apis.example.com</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>We used script-src which is a directive that controls a set of script-related privileges for a specific page. We've\nspecified 'self' as one valid source of script and <a href=\"https://apis.example.com\">https://apis.example.com</a> as another. The browser dutifully downloads\nand executes JavaScript from apis.example.com over HTTPS as well as from the current page's origin.</p>\n<p>While script resources are the most obvious security risks, CSP provides a rich set of policy directives that enable\nfairly granular control over the resources that a page is allowed to load.</p>\n<h3>Policies that applies to a wide variety of resources</h3>\n<p>Let's walk through the rest of the resource directives. The list below represents the state of the directives\nas of level 2 specification. A level 3 spec has been published, but is largely unimplemented in the major browsers.</p>\n<ul>\n<li>base-uri, restricts the URLs that can appear in a page's <code class=\"language-text\">&lt;base></code> element.</li>\n<li>child-src, lists the URLs for workers and embedded frame contents.\nFor example: child-src <a href=\"https://youtube.com\">https://youtube.com</a> would enable embedding videos from YouTube but not from other origins.</li>\n<li>connect-src, limits the origins that you can connect to (via XHR, WebSockets, and EventSource).</li>\n<li>font-src, specifies the origins that can serve web fonts.</li>\n<li>form-action, lists valid endpoints for submission from <code class=\"language-text\">&lt;form></code> tags.</li>\n<li>frame-ancestors, specifies the sources that can embed the current page.\nThis directive applies to <code class=\"language-text\">&lt;frame></code>, <code class=\"language-text\">&lt;iframe></code>, <code class=\"language-text\">&lt;embed></code>, and <code class=\"language-text\">&lt;applet></code> tags.\nThis directive can't be used in <code class=\"language-text\">&lt;meta></code> tags and applies only to non-HTML resources.</li>\n<li>frame-src, was deprecated in level 2, but is restored in level 3.\nIf not present it still falls back to child-src as before.</li>\n<li>img-src, defines the origins from which images can be loaded.</li>\n<li>media-src, restricts the origins allowed to deliver video and audio.</li>\n<li>object-src, allows control over Flash and other plugins.</li>\n<li>plugin-types, limits the kinds of plugins a page may invoke.</li>\n<li>report-uri, specifies a URL where a browser will send reports when a content security policy is violated.\nThis directive can't be used in <code class=\"language-text\">&lt;meta></code> tags.</li>\n<li>style-src, is script-src's counterpart for stylesheets.</li>\n<li>upgrade-insecure-requests, instructs user agents to rewrite URL schemes, changing HTTP to HTTPS.\nThis directive is for websites with large numbers of old URL's that need to be rewritten.</li>\n<li>worker-src, is a CSP Level 3 directive that restricts the URLs that may be loaded as a worker, shared worker, or service worker.</li>\n</ul>\n<p>By default, directives are wide open. If you don't set a specific policy for a directive, let's say font-src, then that\ndirective behaves by default as though you'd specified * as the valid source (for example, you could load fonts from\nanywhere, without restriction).</p>\n<p>You can override this default behavior by specifying a default-src directive. This directive defines the defaults for\nmost directives that you leave unspecified. Generally, this applies to any directive that ends with -src.\nIf default-src is set to <a href=\"https://example.com\">https://example.com</a>, and you fail to specify a font-src directive, then you can load fonts\nfrom <a href=\"https://example.com\">https://example.com</a>, and nowhere else. We specified only script-src in our earlier examples, which means that\nimages, fonts, and so on can be loaded from any origin.</p>\n<p>The following directives don't use default-src as a fallback. Remember that failing to set them is the same as allowing\nanything.</p>\n<ul>\n<li>base-uri</li>\n<li>form-action</li>\n<li>frame-ancestors</li>\n<li>plugin-types</li>\n<li>report-uri</li>\n<li>sandbox</li>\n</ul>\n<p>You can use as many or as few of these directives as makes sense for your specific application, simply listing each in\nthe HTTP header, separating directives with semicolons. Make sure that you list all required resources of a specific\ntype in a single directive. If you wrote something like script-src <a href=\"https://host1.com\">https://host1.com</a>; script-src <a href=\"https://host2.com\">https://host2.com</a> the\nsecond directive would simply be ignored. Something like the following would correctly specify both origins as valid:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">script-src https://host1.com https://host2.com</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>If, for example, you have an application that loads all of its resources from a content delivery network (say,\n<a href=\"https://cdn.example.net\">https://cdn.example.net</a>), and know that you don't need any framed content or plugins, then your policy might look\nsomething like the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Content-Security-Policy: default-src https://cdn.example.net; child-src 'none'; object-src 'none'</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h3>Implementation details of CSP</h3>\n<p>You will see X-WebKit-CSP and X-Content-Security-Policy headers in various tutorials on the web. You should ignore these\nprefixed headers. Modern browsers, except IE, support the un-prefixed Content-Security-Policy header.</p>\n<p>Regardless of the header you use, policy is defined on a page-by-page basis: you'll need to send the HTTP header along\nwith every response that you'd like to ensure is protected. This provides a lot of flexibility, as you can fine-tune\nthe policy for specific pages based on their specific needs. Perhaps one set of pages in your site has a +1 button,\nwhile others don't: you could allow the button code to be loaded only when necessary.</p>\n<p>The source list in each directive is flexible. You can specify sources by scheme (data:, https:), or ranging in\nspecificity from hostname-only (example.com), which matches any origin on that host: any scheme, any port to a fully\nqualified URI (<a href=\"https://example.com:443\">https://example.com:443</a>), which matches only HTTPS, only example.com, and only port 443). Wildcards are\naccepted, but only as a scheme, a port, or in the leftmost position of the hostname: <em>://</em>.example.com:* would match\nall subdomains of example.com (but not example.com itself), using any scheme, on any port.</p>\n<p>The source list also accepts four keywords:</p>\n<ul>\n<li>'none', as you might expect, matches nothing.</li>\n<li>'self' matches the current origin, but not its subdomains.</li>\n<li>'unsafe-inline' allows inline JavaScript and CSS.</li>\n<li>'unsafe-eval' allows text-to-JavaScript mechanisms like eval.</li>\n</ul>\n<p>These keywords require single-quotes. For example, script-src 'self' (with quotes) authorizes the execution of JavaScript\nfrom the current host; script-src self (no quotes) allows JavaScript from a server named \"self\" (and not from the\ncurrent host), which probably isn't what you meant.</p>\n<h3>Sandboxing</h3>\n<p>There's one more directive worth talking about: sandbox. It's a bit different from the others we've looked at, as it\nplaces restrictions on actions that the page can take rather than on resources that the page can load. If the sandbox\ndirective is present, the page is treated as though it was loaded inside of an <code class=\"language-text\">&lt;iframe></code> with a sandbox attribute.\nThis can have a wide range of effects on the page: forcing the page into a unique origin, and preventing form submission,\namong others. It's a bit beyond the scope of this article, but you can find full details on valid sandboxing attributes\nin the \"Sandboxing\" section of the <a href=\"https://html.spec.whatwg.org/dev/origin.html#sandboxing\">HTML5 specification</a></p>\n<h3>The meta tag</h3>\n<p>CSPs preferred delivery mechanism is an HTTP header. It can be useful, however, to set a policy on a page directly in\nthe markup. Do that using a <code class=\"language-text\">&lt;meta></code> tag with a http-equiv attribute:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">&lt;meta http-equiv=\"Content-Security-Policy\" content=\"default-src https://cdn.example.net; child-src 'none'; object-src 'none'\"></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>This can't be used for frame-ancestors, report-uri, or sandbox.</p>\n<h3>Inline code is considered harmful</h3>\n<p>It should be clear that CSP is based on allowlist origins, as that's an unambiguous way of instructing the browser to\ntreat specific sets of resources as acceptable and to reject the rest. Origin-based allowlists don't, however, solve\nthe biggest threat posed by XSS attacks: inline script injection. If an attacker can inject a script tag that directly\ncontains some malicious payload <code class=\"language-text\">&lt;script>sendMyDataToEvilDotCom()&lt;/script></code>, the browser has no mechanism by which to\ndistinguish it from a legitimate inline script tag. CSP solves this problem by banning inline script entirely: it's the\nonly way to be sure.</p>\n<p>This ban includes not only scripts embedded directly in script tags, but also inline event handlers and javascript:\nURLs. You'll need to move the content of script tags into an external file, and replace javascript: URLs and\n<code class=\"language-text\">&lt;a ... onclick=\"[JAVASCRIPT]\"></code> with appropriate <code class=\"language-text\">addEventListener()</code> calls. For example, you might rewrite the\nfollowing from:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">doAmazingThings</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'YOU AM AMAZING!'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>button onclick<span class=\"token operator\">=</span><span class=\"token string\">'doAmazingThings();'</span><span class=\"token operator\">></span>Am <span class=\"token constant\">I</span> amazing<span class=\"token operator\">?</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>to something more like:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> amazing<span class=\"token punctuation\">.</span>html <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>script src<span class=\"token operator\">=</span><span class=\"token string\">'amazing.js'</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>button id<span class=\"token operator\">=</span><span class=\"token string\">'amazing'</span><span class=\"token operator\">></span>Am <span class=\"token constant\">I</span> amazing<span class=\"token operator\">?</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token comment\">// amazing.js</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">doAmazingThings</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'YOU AM AMAZING!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\ndocument<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'DOMContentLoaded'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\ndocument<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'amazing'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> doAmazingThings<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The rewritten code has a number of advantages above and beyond working well with CSP; it's already best practice,\nregardless of your use of CSP. Inline JavaScript mixes structure and behavior in exactly the way you shouldn't.\nExternal resources are easier for browsers to cache, more understandable for developers, and conducive to compilation\nand minification. You'll write better code if you do the work to move code into external resources.</p>\n<p>Inline style is treated in the same way: both the style attribute and style tags should be consolidated into external\nstylesheets to protect against a variety of surprisingly clever data exfiltration methods that CSS enables.</p>\n<p>If you must have inline script and style, you can enable it by adding 'unsafe-inline' as an allowed source in a\nscript-src or style-src directive. You can also use a nonce or a hash (see below), but you really shouldn't. Banning\ninline script is the biggest security win CSP provides, and banning inline style likewise hardens your application.\nIt's a little bit of effort up front to ensure that things work correctly after moving all the code out-of-line, but\nthat's a tradeoff that's well worth making.</p>\n<p><em><strong>If you absolutely must use it</strong></em>, CSP Level 2 offers backward compatibility for inline scripts by allowing you to add\nspecific inline scripts to the allowlist using either a cryptographic nonce (number used once) or a hash. Although this\nmay be cumbersome, it is useful in a pinch.</p>\n<p>To use a nonce, give your script tag a nonce attribute. Its value must match one in the list of trusted sources. For\nexample:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>script nonce<span class=\"token operator\">=</span><span class=\"token string\">\"EDNnf03nceIOfn39fn3e9h3sdfa\"</span><span class=\"token operator\">></span>\n  <span class=\"token comment\">// Some inline code I can't remove yet, but need to asap.</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>Now, add the nonce to your script-src directive appended to the nonce- keyword.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Content-Security-Policy: script-src 'nonce-EDNnf03nceIOfn39fn3e9h3sdfa'</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Remember that nonces must be regenerated for every page request and they must be unguessable.</p>\n<p>Hashes work in much the same way. Instead of adding code to the script tag, create a SHA hash of the script itself and\nadd it to the script-src directive. For example, let's say your page contained this:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span><span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello, world.'</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Your policy would contain this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Content-Security-Policy: script-src 'sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng='</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>There are a few things to note here. The sha*- prefix specifies the algorithm that generates the hash. In the example\nabove, sha256- is used. CSP also supports sha384- and sha512-. When generating the hash, do not include the <code class=\"language-text\">&lt;script></code>\ntags. Also capitalization and whitespace matter, including leading or trailing whitespace.</p>\n<p>A Google search on generating SHA hashes will lead you to solutions in any number of languages. Using Chrome 40 or\nlater, you can open DevTools and then reload your page. The Console tab will contain error messages with the correct\nsha256 hash for each of your inline scripts.</p>\n<h3>Eval too</h3>\n<p>Even when an attacker can't inject script directly, they might be able to trick your application into converting\notherwise inert text into executable JavaScript and executing it on their behalf. <code class=\"language-text\">eval()</code>, <code class=\"language-text\">new Function()</code>,\n<code class=\"language-text\">setTimeout([string], ...)</code>, and <code class=\"language-text\">setInterval([string], ...)</code> are all vectors through which injected text might end up\nexecuting something unexpectedly malicious. CSP's default response to this risk is to completely block all of these vectors.</p>\n<p>This has more than a few impacts on the way you build applications:</p>\n<ul>\n<li>You must parse JSON via the built-in JSON.parse, rather than relying on eval. Native JSON operations are available in every browser since IE8, and they're completely safe.</li>\n<li>Rewrite any setTimeout or setInterval calls you're currently making with inline functions rather than strings. For example:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"document.querySelector('a').style.display = 'none';\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>would be better written as:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>display <span class=\"token operator\">=</span> <span class=\"token string\">'none'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>Avoid inline templating at runtime: Many templating libraries use <code class=\"language-text\">new Function()</code> liberally to speed up template\ngeneration at runtime. It's a nifty application of dynamic programming, but comes at the risk of evaluating malicious text.\nSome frameworks support CSP out of the box, falling back to a robust parser in the absence of eval.</li>\n</ul>\n<p>However, a better choice would be a templating language that offers precompilation (Handlebars does, for instance).\nPrecompiling your templates can make the user experience even faster than the fastest runtime implementation, and it's\nsafer too. If eval and its text-to-JavaScript brethren are essential to your application, you can enable them by adding\n'unsafe-eval' as an allowed source in a script-src directive, but we strongly discourage this. Banning the ability to\nexecute strings makes it much more difficult for an attacker to execute unauthorized code on your site.</p>\n<h3>Reporting</h3>\n<p>CSP's ability to block untrusted resources client-side is a huge win for your users, but it would be quite helpful to\nhave some sort of notification sent back to the server so that you can identify and squash any bugs that allow malicious\ninjection in the first place. To this end, you can instruct the browser to POST JSON-formatted violation reports to a\nlocation specified in a report-uri directive.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Content-Security-Policy: default-src 'self'; ...; report-uri /my_amazing_csp_report_parser;</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Those reports will look something like the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n   <span class=\"token property\">\"csp-report\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token property\">\"document-uri\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"http://example.org/page.html\"</span><span class=\"token punctuation\">,</span>\n   <span class=\"token property\">\"referrer\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"http://evil.example.com/\"</span><span class=\"token punctuation\">,</span>\n   <span class=\"token property\">\"blocked-uri\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"http://evil.example.com/evil.js\"</span><span class=\"token punctuation\">,</span>\n   <span class=\"token property\">\"violated-directive\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"script-src 'self' https://apis.google.com\"</span><span class=\"token punctuation\">,</span>\n   <span class=\"token property\">\"original-policy\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"script-src 'self' https://apis.google.com; report-uri http://example.org/my_amazing_csp_report_parser\"</span>\n   <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>This contains a good chunk of information that will help you track down the specific cause of the violation, including\nthe page on which the violation occurred (document-uri), that page's referrer (note that unlike the HTTP header field,\nthe key is not misspelled), the resource that violated the page's policy (blocked-uri), the specific directive it\nviolated (violated-directive), and the page's complete policy (original-policy).</p>\n<h3>Report only</h3>\n<p>If you're just starting out with CSP, it makes sense to evaluate the current state of your application before rolling\nout a draconian policy to your users. As a stepping stone to a complete deployment, you can ask the browser to monitor\na policy, reporting violations but not enforcing the restrictions. Instead of sending a Content-Security-Policy header,\nsend a Content-Security-Policy-Report-Only header.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Content-Security-Policy-Report-Only: default-src 'self'; ...; report-uri /my_amazing_csp_report_parser;</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>The policy specified in report-only mode won't block restricted resources, but it will send violation reports to the\nlocation you specify. You can even send both headers, enforcing one policy while monitoring another. This is a great\nway to evaluate the effect of changes to your application's CSP: turn on reporting for a new policy, monitor the\nviolation reports and fix any bugs that turn up; when you're satisfied with its effect, start enforcing the new policy.</p>\n<h3>Usage in the real world</h3>\n<p>CSP 1 is quite usable in Chrome, Safari, and Firefox, but has very limited support in IE 10. CSP Level 2 has been\navailable in Chrome since version 40. You can see more at <a href=\"https://caniuse.com/?search=content%20security%20policy%20level%202\">caniuse</a>.\nMassive sites like Twitter and Facebook have deployed the header, and the standard is very much ready for you to start\ndeploying on your own sites.</p>\n<h2>References</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\">SameOriginPolicy</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\">Cross Origing Resource Sharing - CORS</a></li>\n<li><a href=\"https://fetch.spec.whatwg.org/#cors-safelisted-request-header\">CORS Safelisted request headers</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#preflighted_requests\">Pre-flight-requests</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream\">Readable Streams</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP\">Content Security Policy - CSP</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\">XSS-attacks</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/default-src\">CSP-default-src directive</a></li>\n<li><a href=\"https://www.w3.org/TR/CSP3/\">CSP-Level 3 specification</a></li>\n<li><a href=\"https://html.spec.whatwg.org/dev/origin.html#sandboxing\">HTML5 Sandboxing Specification</a></li>\n</ul>"}},"pageContext":{"slug":"/articles/node-http-secorutiy/"}},
    "staticQueryHashes": ["4011214723"]}