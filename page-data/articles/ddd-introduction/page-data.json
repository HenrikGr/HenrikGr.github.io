{
    "componentChunkName": "component---src-templates-article-page-template-js",
    "path": "/articles/ddd-introduction/",
    "result": {"data":{"markdownRemark":{"frontmatter":{"title":"Domain Driven Design - Overview","subtitle":"The case of Domain Driven Design","date":"2021-02-15","publishedBy":"Henrik Grönvall"},"excerpt":"Domain-Driven Design is an approach to software development that centers the development on programming a domain model\nthat has a rich understanding of the…","timeToRead":3,"html":"<p>Domain-Driven Design is an approach to software development that centers the development on programming a domain model\nthat has a rich understanding of the processes and rules of a domain.</p>\n<h1>DDD and it's unifying principle</h1>\n<p>Every software system built has a model at its heart. If this model matches the underlying domain well, the software\nwill accept enhancements more easily, and it has a much better chance of surviving and thriving intact for years.\nThe model may not be obvious; it may exist only in the mind of the developers, but it exists nonetheless.\nElegant designs are possible in any paradigm.</p>\n<p>It's this alignment that matters, and achieving and maintaining alignment is the fundamental purpose of DDD.</p>\n<h2>It's a continuous process</h2>\n<p>Striving for model-domain harmony never ends, as long as the business keeps changing. That's alright, because DDD\nis a continuous process.</p>\n<h2>DDD philosophy</h2>\n<p>Ubiquitous Language is the term used in Domain Driven Design for the practice of building up a common, rigorous\nlanguage between developers and stakeholders. This language should be based on the Domain Model used in the\nsoftware - hence the need for it to be rigorous, since software doesn't cope well with ambiguity.</p>\n<p>Using the ubiquitous language in conversations with domain experts is an important part of testing it, and hence\nthe domain model.</p>\n<p>This emphasis on pure definitions and unified communications, within specific boundaries, is the glue that holds it all\ntogether, the philosophical principle that keep everything else on track. The strategic, tactical, and technical aspects\nof DDD are intended to support and enforce this philosophy.</p>\n<h2>The strategic aspect</h2>\n<p>The strategic aspect of DDD aligns software development teams' efforts with the interests of the business. It helps when\ndeciding what to focus on, usually by identifying one core domain. This may be a specific area of business or even a\nspecific slice that's critical.</p>\n<h2>The tactical aspect</h2>\n<p>The tactical, technical aspect of DDD guides the implementation process with the fundamental purpose of protecting the\nmodel from corruption. The patterns and architectural structures commonly associated with DDD flow naturally from this\nconstraint, to provide the requisite layers of protection.</p>\n<h2>Why it's hard?</h2>\n<p>In many ways, DDD is considered hard to do right: it takes a certain amount of self-discipline to adhere to the\nphilosophy and requires another level of restraint to resist designing when you should be modeling. It also takes\ncourage to keep asking \"What does this really mean?\" and \"Why does this happen?\" until the deeper model is uncovered.</p>\n<p>It also requires patience to keep refining, refactoring, iterating, and accepting feedback until the model,\nthe code, and the business coalesce into a cooperative synergy.</p>\n<h2>Do it anyway?</h2>\n<p>If you're building simple applications in a simple domain, your model will also be simple, and so shouldn't be\nexcessively time-consuming to discover. That doesn't mean that crafting it will be easy, though. Above all, you must\ncommit to learning about the business. You can't help the business develop its capabilities without understanding the\nbusiness.</p>\n<p>A little DDD can go a long way. Even if you decide not to continue DDD practices past the initial model, or only go for\na few iterations, you'll be able to make that decision from a position of knowledge.</p>\n<h2>Classifications</h2>\n<p>In his excellent book <a href=\"https://www.amazon.com/gp/product/0321125215\">Domain Driven Design</a>, Eric Evans creates a\nclassification of the different kinds of domain objects that you're likely to run into.</p>\n<ul>\n<li>Entity: Objects that have a distinct identity that runs through time and different representations. You also hear\nthese called \"reference objects\".</li>\n<li>Value Object: Objects that matter only as the combination of their attributes. Two value objects with the same values\nfor all their attributes are considered equal.</li>\n<li>Service: A standalone operation within the context of your domain. A Service Object collects one or more services into\nan object. Typically, you will have only one instance of each service object type within your execution context.</li>\n<li>Aggregate: An aggregate is a cluster of domain objects that can be treated as a single unit. An aggregate will have\none of its component objects be the aggregate root. Any references from outside the aggregate should only go to the\naggregate root. The root can thus ensure the integrity of the aggregate as a whole</li>\n</ul>\n<p>I will write more about these domain objects in future articles and, provide code examples from a simple domain.</p>\n<h2>Before you start with DDD</h2>\n<p>Domain-Driven Developers need to be comfortable with the following:</p>\n<ul>\n<li>Object-Oriented Programming Basics</li>\n<li>Object-Oriented Programming Design Principles such as,\n<ul>\n<li>composition,</li>\n<li>encapsulation,</li>\n<li>inheritance,</li>\n<li>referring to abstractions, and</li>\n<li>SOLID Principles.</li>\n</ul>\n</li>\n<li>General Design Principles such as,\n<ul>\n<li>KISS, and</li>\n<li>DRY.</li>\n</ul>\n</li>\n</ul>"}},"pageContext":{"slug":"/articles/ddd-introduction/"}},
    "staticQueryHashes": ["4011214723"]}