{
    "componentChunkName": "component---src-templates-article-page-template-js",
    "path": "/articles/node--session-authentication/",
    "result": {"data":{"markdownRemark":{"frontmatter":{"title":"Session management for web applications","subtitle":"An introduction to session management for web application","date":"2021-04-26","publishedBy":"Henrik Grönvall"},"excerpt":"A web session is a sequence of network HTTP request and response transactions associated with the same user. Modern and\ncomplex web applications require the…","timeToRead":14,"html":"<p>A web session is a sequence of network HTTP request and response transactions associated with the same user. Modern and\ncomplex web applications require the retaining of information or status about each user for the duration of multiple\nrequests. Therefore, sessions provide the ability to establish variables – such as access rights and localization\nsettings – which will apply to each and every interaction a user has with the web application for the duration of\nthe session.</p>\n<h1>Session management for web applications</h1>\n<p>Web applications can create sessions to keep track of anonymous users after the very first user request. An example\nwould be maintaining the user language preference. Additionally, web applications will make use of sessions once the\nuser has authenticated. This ensures the ability to identify the user on any subsequent requests as well as being able\nto apply security access controls, authorized access to the user private data, and to increase the usability of the\napplication. Therefore, current web applications can provide session capabilities both pre and post authentication.</p>\n<p>Once an authenticated session has been established, the session ID (or token) is temporarily equivalent to the strongest\nauthentication method used by the application, such as username and password, passphrases, one-time passwords (OTP),\nclient-based digital certificates, smartcards, or biometrics (such as fingerprint or eye retina).</p>\n<p>HTTP is a stateless protocol (<a href=\"https://www.ietf.org/rfc/rfc2616.txt\">RFC2616 section 5</a>), where each request and response\npair is independent of other web interactions. Therefore, in order to introduce the concept of a session, it is required\nto implement session management capabilities that link both the authentication and access control (or authorization)\nmodules commonly available in web applications.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 753px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/36d3c80e98dcb8157df9ad88f329baba/17a7a/Session_Management_Cheat_Sheet_Diagram.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.76785714285714%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABcSAAAXEgFnn9JSAAABe0lEQVQY0y3K2y9bAQCA8fPPjIjMmyzGVv4HyczOkNNgriGSJR4m0o7GdZEGTSeSJR7U/fLQpXHqVEtJR0I2XRVRNQ+kq56qxnHqE+Lhl3wPnxBLavyL3+L+m0AOJlgJJlBCCW40nTs9w4WqEUtliF3rXKoaeuaeZFrHHbxCfvbY/6810ncgfDTN0jq+TZFpHYPZx1uzj9edXnZPVXaOrpCsAWqG1qi1+qge2WE/qrIRjlNg8mMwe59+Q/cWVtcJbTYPgiR10WSZ5VWDnTeNdgobbBQ2fufHWoRFOYRUO4hYZaLS2E198wjLyiFj7mNK2ufIr+ohv8JCcfsc3xzbSHX9CKPvjHR8GSVLHCBP7OWl2EdOmQXv/hmRwB5jYjMTNZ+fjFe2cP77AOevQ16Umsl930Vu2Veyy3uw2ZcY/vAJ4UyWCf8J4XBt4XCuM+ncYMa1STJ9i6aqRFYVooqH6KrCqeJBv0kRT6aY+unH8cjpZ3olQCR8wsH8Ag+R8ixjNPEXygAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"SessionAuthentication\"\n        title=\"Session management\"\n        src=\"/static/36d3c80e98dcb8157df9ad88f329baba/17a7a/Session_Management_Cheat_Sheet_Diagram.png\"\n        srcset=\"/static/36d3c80e98dcb8157df9ad88f329baba/80b2d/Session_Management_Cheat_Sheet_Diagram.png 224w,\n/static/36d3c80e98dcb8157df9ad88f329baba/33b38/Session_Management_Cheat_Sheet_Diagram.png 448w,\n/static/36d3c80e98dcb8157df9ad88f329baba/17a7a/Session_Management_Cheat_Sheet_Diagram.png 753w\"\n        sizes=\"(max-width: 753px) 100vw, 753px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>The session ID or token binds the user authentication credentials (in the form of a user session) to the user HTTP\ntraffic and, the appropriate access controls enforced by the web application. The complexity of these three components\n(authentication, session management, and access control) in modern web applications, plus the fact that its\nimplementation and binding resides on the web developer's hands (as web development frameworks do not provide strict\nrelationships between these modules), makes the implementation of a secure session management module very challenging.</p>\n<h1>Session management implementation</h1>\n<p>The session management implementation defines the exchange mechanism that will be used between the user and, the web\napplication to share and continuously exchange the session ID. There are multiple mechanisms available in HTTP to\nmaintain session state within web applications, such as cookies (standard HTTP header),\nURL parameters (URL rewriting – <a href=\"https://www.ietf.org/rfc/rfc2396.txt\">RFC2396</a>), URL arguments on GET requests, body\narguments on POST requests, such as hidden form fields (HTML forms), or proprietary HTTP headers.</p>\n<p>The preferred session ID exchange mechanism should allow defining advanced token properties, such as the token expiration\ndate and time, or granular usage constraints. This is one of the reasons why cookies (RFCs <a href=\"https://www.ietf.org/rfc/rfc2109.txt\">2109</a> &#x26;\n<a href=\"https://www.ietf.org/rfc/rfc2965.txt\">2965</a> &#x26; <a href=\"https://www.ietf.org/rfc/rfc6265.txt\">6265</a>) are one of the most extensively used session ID exchange mechanisms, offering advanced capabilities not available in\nother methods.</p>\n<p>The usage of specific session ID exchange mechanisms, such as those where the ID is included in the URL, might disclose\nthe session ID (in web links and logs, web browser history and bookmarks, the Referer header or search engines), as well\nas facilitate other attacks, such as the manipulation of the ID or <a href=\"http://www.acrossecurity.com/papers/session_fixation.pdf\">session fixation attacks</a>.</p>\n<h2>Cookies</h2>\n<p>Session management mechanisms based on cookies can make use of two types of cookies, non-persistent (or session)\ncookies, and persistent cookies. If a cookie presents the Max-Age (that has preference over Expires) or Expires\nattributes, it will be considered a persistent cookie and will be stored on disk by the web browser based until the\nexpiration time.</p>\n<p>The session ID exchange mechanism based on cookies provides multiple security features in the form of cookie attributes\nthat can be used to protect the exchange of the session ID, Secure, HttpOnly, Expires, maxAge attributes, etc.</p>\n<h3>Secure attribute</h3>\n<p>The Secure cookie attribute instructs web browsers to only send the cookie through an encrypted HTTPS (SSL/TLS)\nconnection. This session protection mechanism is mandatory to prevent the disclosure of the session ID through MitM\n(Man-in-the-Middle) attacks. It ensures that an attacker cannot simply capture the session ID from web browser traffic.</p>\n<p>Forcing the web application to only use HTTPS for its communication (even when port TCP/80, HTTP, is closed in the web\napplication host) does not protect against session ID disclosure if the Secure cookie has not been set - the web\nbrowser can be deceived to disclose the session ID over an unencrypted HTTP connection. The attacker can intercept\nand manipulate the victim user traffic and inject an HTTP unencrypted reference to the web application that will force\nthe web browser to submit the session ID in the clear.</p>\n<h3>HttpOnly attribute</h3>\n<p>The HttpOnly cookie attribute instructs web browsers not to allow scripts (e.g. JavaScript or VBscript) an ability to\naccess the cookies via the DOM document.cookie object. This session ID protection is mandatory to prevent session ID\nstealing through XSS attacks. However, if an XSS attack is combined with a CSRF attack, the requests sent to the web\napplication will include the session cookie, as the browser always includes the cookies when sending requests. The\nHttpOnly cookie only protects the confidentiality of the cookie; the attacker cannot use it offline, outside of the\ncontext of an XSS attack.</p>\n<h3>SameSite attribute</h3>\n<p>SameSite allows a server define a cookie attribute making it impossible to the browser send this cookie along with\ncross-site requests. The main goal is to mitigate the risk of cross-origin information leakage, and provides some\nprotection against cross-site request forgery attacks.</p>\n<h3>Expire and maxAge attributes</h3>\n<p>Session management mechanisms based on cookies can make use of two types of cookies, non-persistent (or session)\ncookies, and persistent cookies. If a cookie presents the Max-Age (that has preference over Expires) or Expires\nattributes, it will be considered a persistent cookie and will be stored on disk by the web browser based until the\nexpiration time.</p>\n<p>Typically, session management capabilities to track users after authentication make use of non-persistent cookies.\nThis forces the session to disappear from the client if the current web browser instance is closed. Therefore, it is\nhighly recommended to use non-persistent cookies for session management purposes, so that the session ID does not\nremain on the web client cache for long periods of time, from where an attacker can obtain it.</p>\n<ul>\n<li>Ensure that sensitive information is not comprised, by ensuring that sensitive information is not persistent /\nencrypting / stored on a need basis for the duration of the need.</li>\n<li>Ensure that unauthorized activities cannot take place via cookie manipulation.</li>\n<li>Ensure secure flag is set to prevent accidental transmission over \"the wire\" in a non-secure manner.</li>\n<li>Determine if all state transitions in the application code properly check for the cookies and enforce their use</li>\n<li>Ensure entire cookie should be encrypted if sensitive data is persisted in the cookie</li>\n<li>Define all cookies being used by the application, their name and why they are needed</li>\n</ul>\n<h2>Session id lifecycle</h2>\n<p>There are two types of session management mechanisms for web applications, permissive and strict, related to session\nfixation vulnerabilities. The permissive mechanism allows the web application to initially accept any session ID value\nset by the user as valid, creating a new session for it, while the strict mechanism enforces that the web application\nwill only accept session ID values that have been previously generated by the web application.</p>\n<p>The session tokens should be handled by the web server if possible or generated via a cryptographically secure random\nnumber generator.</p>\n<p>Although the most common mechanism in use today is the strict one (more secure), PHP defaults to permissive. Developers\nmust ensure that the web application does not use a permissive mechanism under certain circumstances. Web applications\nshould never accept a session ID they have never generated, and in case of receiving one, they should generate and\noffer the user a new valid session ID. Additionally, this scenario should be detected as a suspicious activity and,\nan alert should be generated.</p>\n<h3>Manage Session ID as Any Other User Input</h3>\n<p>Session IDs must be considered untrusted, as any other user input processed by the web application, and they must be\nthoroughly validated and verified. Depending on the session management mechanism used, the session ID will be received\nin a GET or POST parameter, in the URL or in an HTTP header (e.g. cookies). If web applications do not validate and\nfilter out invalid session ID values before processing them, they can potentially be used to exploit other web\nvulnerabilities, such as SQL injection if the session IDs are stored on a relational database, or persistent XSS if the\nsession IDs are stored and reflected back afterwards by the web application.</p>\n<h3>Renew the Session ID After Any Privilege Level Change</h3>\n<p>The session ID must be renewed or regenerated by the web application after any privilege level change within the\nassociated user session. The most common scenario where the session ID regeneration is mandatory is during the\nauthentication process, as the privilege level of the user changes from the unauthenticated (or anonymous) state to\nthe authenticated state. Other common scenarios must also be considered, such as password changes, permission changes\nor switching from a regular user role to an administrator role within the web application. For all these web application\ncritical pages, previous session IDs have to be ignored, a new session ID must be assigned to every new request\nreceived for the critical resource, and the old or previous session ID must be destroyed.</p>\n<p>The session ID regeneration is mandatory to prevent session fixation attacks, where an attacker sets the session ID on\nthe victim user's web browser instead of gathering the victim's session ID, as in most of the other session-based\nattacks, and independently of using HTTP or HTTPS. This protection mitigates the impact of other web-based\nvulnerabilities that can also be used to launch session fixation attacks, such as HTTP response splitting or XSS\n(see here and here).</p>\n<p>A complementary recommendation is to use a different session ID or token name (or set of session IDs) pre and post\nauthentication, so that the web application can keep track of anonymous users and authenticated users without the\nrisk of exposing or binding the user session between both states.</p>\n<h2>Session expiration</h2>\n<p>In order to minimize the time period an attacker can launch attacks over active sessions and hijack them, it is\nmandatory to set expiration timeouts for every session, establishing the amount of time a session will remain active.\nInsufficient session expiration by the web application increases the exposure of other session-based attacks, as for\nthe attacker to be able to reuse a valid session ID and hijack the associated session, it must still be active.</p>\n<p>The shorter the session interval is, the lesser the time an attacker has to use the valid session ID. The session\nexpiration timeout values must be set accordingly with the purpose and nature of the web application, and balance\nsecurity and usability, so that the user can comfortably complete the operations within the web application without\nhis session frequently expiring.</p>\n<p>Both the idle and absolute timeout values are highly dependent on how critical the web application and its data are.\nCommon idle timeouts ranges are 2-5 minutes for high-value applications and 15-30 minutes for low risk applications.\nAbsolute timeouts depend on how long a user usually uses the application. If the application is intended to be used\nby an office worker for a full day, an appropriate absolute timeout range could be between 4 and 8 hours.</p>\n<p>When a session expires, the web application must take active actions to invalidate the session on both sides, client\nand server. The latter is the most relevant and mandatory from a security perspective.</p>\n<p>For most session exchange mechanisms, client side actions to invalidate the session ID are based on clearing out the\ntoken value. For example, to invalidate a cookie it is recommended to provide an empty (or invalid) value for the\nsession ID, and set the Expires (or Max-Age) attribute to a date from the past (in case a persistent cookie is\nbeing used): Set-Cookie: id=; Expires=Friday, 17-May-03 18:45:00 GMT.</p>\n<p>In order to close and invalidate the session on the server side, it is mandatory for the web application to take active\nactions when the session expires, or the user actively logs out.</p>\n<h3>Automatic Session Expiration</h3>\n<h4>Idle timeout</h4>\n<p>All sessions should implement an idle or inactivity timeout. This timeout defines the amount of time a session will\nremain active in case there is no activity in the session, closing and invalidating the session upon the defined idle\nperiod since the last HTTP request received by the web application for a given session ID.</p>\n<p>The idle timeout limits the chances an attacker has to guess and use a valid session ID from another user. However,\nif the attacker is able to hijack a given session, the idle timeout does not limit the attacker's actions, as he can\ngenerate activity on the session periodically to keep the session active for longer periods of time.</p>\n<p>Session timeout management and expiration must be enforced server-side. If the client is used to enforce the session\ntimeout, for example using the session token or other client parameters to track time references (e.g. number of\nminutes since login time), an attacker could manipulate these to extend the session duration.</p>\n<h4>Absolute timeout</h4>\n<p>All sessions should implement an absolute timeout, regardless of session activity. This timeout defines the maximum\namount of time a session can be active, closing and invalidating the session upon the defined absolute period since\nthe given session was initially created by the web application. After invalidating the session, the user is forced to\n(re)authenticate again in the web application and establish a new session.</p>\n<p>The absolute session limits the amount of time an attacker can use a hijacked session and impersonate the victim user.</p>\n<h4>Renewal timeout</h4>\n<p>Alternatively, the web application can implement an additional renewal timeout after which the session ID is\nautomatically renewed, in the middle of the user session, and independently of the session activity and, therefore,\nof the idle timeout.</p>\n<p>After a specific amount of time since the session was initially created, the web application can regenerate a new ID\nfor the user session and try to set it, or renew it, on the client. The previous session ID value would still be valid\nfor some time, accommodating a safety interval, before the client is aware of the new ID and starts using it. At that\ntime, when the client switches to the new ID inside the current session, the application invalidates the previous ID.</p>\n<p>This scenario minimizes the amount of time a given session ID value, potentially obtained by an attacker, can be reused\nto hijack the user session, even when the victim user session is still active. The user session remains alive and open\non the legitimate client, although its associated session ID value is transparently renewed periodically during the\nsession duration, every time the renewal timeout expires. Therefore, the renewal timeout complements the idle and\nabsolute timeouts, specially when the absolute timeout value extends significantly over time (e.g. it is an application\nrequirement to keep the user sessions open for long periods of time).</p>\n<p>Depending on the implementation, potentially there could be a race condition where the attacker with a still valid\nprevious session ID sends a request before the victim user, right after the renewal timeout has just expired, and\nobtains first the value for the renewed session ID. At least in this scenario, the victim user might be aware of the\nattack as her session will be suddenly terminated because her associated session ID is not valid anymore.</p>\n<h3>Manual Session Expiration</h3>\n<p>Web applications should provide mechanisms that allow security aware users to actively close their session once they\nhave finished using the web application.</p>\n<h4>Logout button</h4>\n<p>Web applications must provide a visible and easily accessible logout (logoff, exit, or close session) button that is\navailable on the web application header or menu and reachable from every web application resource and page, so that\nthe user can manually close the session at any time.</p>\n<h3>Web content caching</h3>\n<p>Even after the session has been closed, it might be possible to access the private or sensitive data exchanged within\nthe session through the web browser cache. Therefore, web applications must use restrictive cache directives for all\nthe web traffic exchanged through HTTP and HTTPS, such as the Cache-Control and Pragma HTTP headers, and/or equivalent\nMETA tags on all or (at least) sensitive web pages.</p>\n<p>Independently of the cache policy defined by the web application, if caching web application contents is allowed, the\nsession IDs must never be cached, so it is highly recommended using the\nCache-Control: no-cache=\"Set-Cookie, Set-Cookie2\" directive, to allow web clients to cache everything except the\nsession ID (see here).</p>\n<h2>Additional Client-Side Defenses for Session Management</h2>\n<p>Web applications can complement the previously described session management defenses with additional countermeasures on\nthe client side. Client-side protections, typically in the form of JavaScript checks and verifications, are not\nbullet-proof and can easily be defeated by a skilled attacker, but can introduce another layer of defense that has to\nbe bypassed by intruders.</p>\n<h3>Initial login timeout</h3>\n<p>Web applications can use JavaScript code in the login page to evaluate and measure the amount of time since the page\nwas loaded and, a session ID was granted. If a login attempt is tried after a specific amount of time, the client code\ncan notify the user that the maximum amount of time to log in has passed and reload the login page, hence retrieving a\nnew session ID.</p>\n<p>This extra protection mechanism tries to force the renewal of the session ID pre-authentication, avoiding scenarios\nwhere a previously used (or manually set) session ID is reused by the next victim using the same computer, for example,\nin session fixation attacks.</p>\n<h3>Force Session Logout On Web Browser Window Close Events</h3>\n<p>Web applications can use JavaScript code to capture all the web browser tab or window close (or even back) events and\ntake the appropriate actions to close the current session before closing the web browser, emulating that the user has\nmanually closed the session via the logout button.</p>\n<h3>Disable Web Browser Cross-Tab Sessions</h3>\n<p>Web applications can use JavaScript code once the user has logged in and a session has been established to force the\nuser to re-authenticate if a new web browser tab or window is opened against the same web application. The web\napplication does not want to allow multiple web browser tabs or windows to share the same session. Therefore, the\napplication tries to force the web browser to not share the same session ID simultaneously between them.</p>\n<blockquote>\n<p>NOTE: This mechanism cannot be implemented if the session ID is exchanged through cookies, as cookies are shared by\nall web browser tabs/windows.</p>\n</blockquote>\n<h3>Automatic client logout</h3>\n<p>JavaScript code can be used by the web application in all (or critical) pages to automatically logout client sessions\nafter the idle timeout expires, for example, by redirecting the user to the logout page (the same resource used by the\nlogout button mentioned previously).</p>\n<p>The benefit of enhancing the server-side idle timeout functionality with client-side code is that the user can see that\nthe session has finished due to inactivity, or even can be notified in advance that the session is about to expire\nthrough a count down timer and warning messages. This user-friendly approach helps to avoid loss of work in web pages\nthat require extensive input data due to server-side silently expired sessions.</p>"}},"pageContext":{"slug":"/articles/node--session-authentication/"}},
    "staticQueryHashes": ["4011214723"]}