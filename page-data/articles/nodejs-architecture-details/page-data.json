{"componentChunkName":"component---src-templates-article-page-template-js","path":"/articles/nodejs-architecture-details/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Node.js architecture - details","subtitle":"Article about the event loop in Node.js","date":"2018-01-20","publishedBy":"Henrik Grönvall"},"excerpt":"As a software developer it is very important that we choose our tools, platforms and methodologies, etc right. We need \nto decide what is the actual value we…","timeToRead":12,"html":"<p>As a software developer it is very important that we choose our tools, platforms and methodologies, etc right. We need\nto decide what is the actual value we are trying to help deliver and select wisely. </p>\n<h1>Node.js is single threaded</h1>\n<p>Lets try to clarify what that means, Node.js is single threaded and it is different to some of the popular server side\ntechnologies such as PHP, ASP.NET, Ruby &#x26; Java Servers that all follow multi-threaded design where each client request\nresults in the instantiation of a new thread or even a process, instead Node.js requests are run on the same thread with\neven shared resources. </p>\n<p>There is only one thread that executes JavaScript code and this is the thread where the event loop is running. The\nexecution of callbacks (know that every application code in a running Node.js application is a callback) is done by\nthe event loop. </p>\n<h1>What is the event loop?</h1>\n<p>The event loop is what allows Node.js to perform non-blocking I/O operations — despite the fact that JavaScript is\nsingle-threaded — by offloading operations to the system kernel whenever possible.</p>\n<p>Since most modern kernels are multi-threaded, they can handle multiple operations executing in the background. When one\nof these operations completes, the kernel tells Node.js so that the appropriate callback may be added to the poll queue\nto eventually be executed.</p>\n<h1>Event loop explained</h1>\n<p>When Node.js starts, it initializes the event loop, processes the provided input script (or drops into the REPL, which\nis not covered in this document) which may make async API calls, schedule timers, or call process.nextTick(), then begins\nprocessing the event loop.</p>\n<p>The following diagram shows a simplified overview of the event loop's order of operation</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 786px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/41b065e631696ffeb6f7ade8c9a04e37/321ea/nodejs-architecture-simple.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.67857142857143%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA4UlEQVQoz52SaQqDMBSEcw6FGuMS17pSQez9jzV9k1aQloLxx0M08cssUTqOkVuLNMsQG4NbFCEIAoRheGmUFdi961DVNYqydGCtNWI56MqoUiDdMGAYR9RNgyRJfoB8PzuqKAo0besUllWFNE2hxfZxkw9UETbNMx7L4qwTSACVGsmU4xOBYiFUZkUp1RKUSY60z8Myz0xVnufo+v5digD357ptWJ9PsDRvoFMoP9qDwkq+sXWuewEJGafJ2SOYMC4YAe85egGpgnlxaDdhy1/N7S2fAhLEDIePyn/38KzCF51KNa3TTi+HAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"node.js architecture\"\n        title=\"Architecture\"\n        src=\"/static/41b065e631696ffeb6f7ade8c9a04e37/321ea/nodejs-architecture-simple.png\"\n        srcset=\"/static/41b065e631696ffeb6f7ade8c9a04e37/80b2d/nodejs-architecture-simple.png 224w,\n/static/41b065e631696ffeb6f7ade8c9a04e37/33b38/nodejs-architecture-simple.png 448w,\n/static/41b065e631696ffeb6f7ade8c9a04e37/321ea/nodejs-architecture-simple.png 786w\"\n        sizes=\"(max-width: 786px) 100vw, 786px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Note: each box here is referred to as a “phase” of the event loop.</p>\n<p>Each phase has a FIFO queue of callbacks to execute. While each phase is special in its own way, generally, when the\nevent loop enters a given phase, it will perform any operations specific to that phase, then execute callbacks in that\nphase's queue until the queue has been exhausted or the maximum number of callbacks has executed. When the queue has\nbeen exhausted or the callback limit is reached, the event loop will move to the next phase, and so on.</p>\n<p>Since any of these operations may schedule more operations and new events processed in the poll phase are queued by the\nkernel, poll events can be queued while polling events are being processed. As a result, long running callbacks can\nallow the poll phase to run much longer than a timer's threshold. See the timers and poll sections for more details.</p>\n<p>NOTE: There is a slight discrepancy between the Windows and the Unix/Linux implementation, but that's not important for\nthis demonstration. The most important parts are here. There are actually seven or eight steps, but the ones we care\nabout — ones that Node.js actually uses - are those above.</p>\n<h1>Phases Overview</h1>\n<ul>\n<li>timers: this phase executes callbacks scheduled by setTimeout() and setInterval().</li>\n<li>pending callbacks: executes I/O callbacks deferred to the next loop iteration.</li>\n<li>idle, prepare: only used internally.</li>\n<li>poll: retrieve new I/O events; execute I/O related callbacks (almost all with the exception of close callbacks,\nthe ones scheduled by timers, and setImmediate()); node will block here when appropriate.</li>\n<li>check: setImmediate() callbacks are invoked here.</li>\n<li>close callbacks: some close callbacks, e.g. socket.on('close', ...).</li>\n</ul>\n<p>Between each run of the event loop, Node.js checks if it is waiting for any asynchronous I/O or timers and shuts down\ncleanly if there are not any.</p>\n<h1>Phases in Detail</h1>\n<p><strong>timers</strong>\nA timer specifies the threshold after which a provided callback may be executed rather than the exact time a person\nwants it to be executed. Timers callbacks will run as early as they can be scheduled after the specified amount of time\nhas passed; however, Operating System scheduling or the running of other callbacks may delay them.</p>\n<p>Note: Technically, the poll phase controls when timers are executed.</p>\n<p>For example, say you schedule a timeout to execute after a 100 ms threshold, then your script starts asynchronously\nreading a file which takes 95 ms:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">someAsyncOperation</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Assume this takes 95ms to complete</span>\n  fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFile</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/path/to/file'</span><span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> timeoutScheduled <span class=\"token operator\">=</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> delay <span class=\"token operator\">=</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> timeoutScheduled<span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>delay<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">ms have passed since I was scheduled</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// do someAsyncOperation which takes 95 ms to complete</span>\n<span class=\"token function\">someAsyncOperation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> startCallback <span class=\"token operator\">=</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// do something that will take 10ms...</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> startCallback <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// do nothing</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>When the event loop enters the poll phase, it has an empty queue (fs.readFile() has not completed), so it will wait for\nthe number of ms remaining until the soonest timer's threshold is reached. While it is waiting 95 ms pass, fs.readFile()\nfinishes reading the file and its callback which takes 10 ms to complete is added to the poll queue and executed.\nWhen the callback finishes, there are no more callbacks in the queue, so the event loop will see that the threshold of\nthe soonest timer has been reached then wrap back to the timers phase to execute the timer's callback. In this example,\nyou will see that the total delay between the timer being scheduled and its callback being executed will be 105ms.</p>\n<p>Note: To prevent the <strong>poll</strong> phase from starving the event loop, libuv (the C library that implements the Node.js event\nloop and all of the asynchronous behaviors of the platform) also has a hard maximum (system dependent) before it stops\npolling for more events.</p>\n<p><strong>pending callbacks</strong>\nThis phase executes callbacks for some system operations such as types of TCP errors. For example if a TCP socket receives\nECONNREFUSED when attempting to connect, some *nix systems want to wait to report the error. This will be queued to\nexecute in the <strong>pending callbacks phase</strong>.</p>\n<p><strong>poll</strong>\nThe poll phase has two main functions:</p>\n<ol>\n<li>Calculating how long it should block and poll for I/O, then</li>\n<li>Processing events in the <strong>poll</strong> queue.</li>\n</ol>\n<p>When the event loop enters the <strong>poll</strong> phase and there are no timers scheduled, one of two things will happen:</p>\n<ul>\n<li>If the <strong>poll</strong> queue is not empty, the event loop will iterate through its queue of callbacks executing them synchronously\nuntil either the queue has been exhausted, or the system-dependent hard limit is reached.</li>\n<li>\n<p>If the <strong>poll</strong> queue is empty, one of two more things will happen:</p>\n<ul>\n<li>If scripts have been scheduled by setImmediate(), the event loop will end the <strong>poll</strong> phase and continue to the\n<strong>check phase</strong> to execute those scheduled scripts.</li>\n<li>If scripts have not been scheduled by setImmediate(), the event loop will wait for callbacks to be added to the queue,\nthen execute them immediately.</li>\n</ul>\n</li>\n</ul>\n<p>Once the <strong>poll</strong> queue is empty the event loop will check for timers whose time thresholds have been reached. If one or\nmore timers are ready, the event loop will wrap back to the timers phase to execute those timers' callbacks.</p>\n<p><strong>check</strong>\nThis phase allows a person to execute callbacks immediately after the <strong>poll</strong> phase has completed. If the <strong>poll</strong> phase\nbecomes idle and scripts have been queued with setImmediate(), the event loop may continue to the <strong>check phase</strong> rather than waiting.</p>\n<p>setImmediate() is actually a special timer that runs in a separate phase of the event loop. It uses a libuv API that\nschedules callbacks to execute after the <strong>poll</strong> phase has completed.</p>\n<p>Generally, as the code is executed, the event loop will eventually hit the <strong>poll</strong> phase where it will wait for an incoming\nconnection, request, etc. However, if a callback has been scheduled with setImmediate() and the <strong>poll</strong> phase becomes idle,\nit will end and continue to the <strong>check</strong> phase rather than waiting for poll events.</p>\n<p><strong>close callbacks</strong>\nIf a socket or handle is closed abruptly (e.g. socket.destroy()), the 'close' event will be emitted in this phase.\nOtherwise it will be emitted via process.nextTick()</p>\n<h1>setImmediate() vs setTimeout()</h1>\n<p>setImmediate() and setTimeout() are similar, but behave in different ways depending on when they are called.</p>\n<ul>\n<li>setImmediate() is designed to execute a script once the current poll phase completes.</li>\n<li>setTimeout() schedules a script to be run after a minimum threshold in ms has elapsed.</li>\n</ul>\n<p>The order in which the timers are executed will vary depending on the context in which they are called. If both are\ncalled from within the main module, then timing will be bound by the performance of the process (which can be impacted\nby other applications running on the machine).</p>\n<p>For example, if we run the following script which is not within an I/O cycle (i.e. the main module), the order in which\nthe two timers are executed is non-deterministic, as it is bound by the performance of the process:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token comment\">// timeout_vs_immediate.js</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'timeout'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">setImmediate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'immediate'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">$ node timeout_vs_immediate.js\n<span class=\"token function\">timeout</span>\nimmediate\n\n$ node timeout_vs_immediate.js\nimmediate\n<span class=\"token function\">timeout</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>However, if you move the two calls within an I/O cycle, the immediate callback is always executed first:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token comment\">// timeout_vs_immediate.js</span>\n<span class=\"token keyword\">const</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span>\n\nfs<span class=\"token punctuation\">.</span><span class=\"token function\">readFile</span><span class=\"token punctuation\">(</span>__filename<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'timeout'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">setImmediate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'immediate'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">$ node timeout_vs_immediate.js\nimmediate\n<span class=\"token function\">timeout</span>\n\n$ node timeout_vs_immediate.js\nimmediate\n<span class=\"token function\">timeout</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The main advantage to using setImmediate() over setTimeout() is setImmediate() will always be executed before any timers\nif scheduled within an I/O cycle, independently of how many timers are present.</p>\n<h1>process.nextTick()</h1>\n<p><strong>Understanding process.nextTick()</strong></p>\n<p>You may have noticed that process.nextTick() was not displayed in the diagram, even though it's a part of the asynchronous API.\nThis is because process.nextTick() is not technically part of the event loop. Instead, the nextTickQueue will be processed\nafter the current operation is completed, regardless of the current phase of the event loop. Here, an operation is defined\nas a transition from the underlying C/C++ handler, and handling the JavaScript that needs to be executed.</p>\n<p>Looking back at our diagram, any time you call process.nextTick() in a given phase, all callbacks passed to process.nextTick()\nwill be resolved before the event loop continues. This can create some bad situations because <strong>it allows you to \"starve\"\nyour I/O by making recursive process.nextTick() calls</strong>, which prevents the event loop from reaching the poll phase.</p>\n<p><strong>Why would that be allowed?</strong>\nWhy would something like this be included in Node.js? Part of it is a design philosophy where an API should always be\nasynchronous even where it doesn't have to be. Take this code snippet for example:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">apiCall</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arg<span class=\"token punctuation\">,</span> callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> arg <span class=\"token operator\">!==</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> process<span class=\"token punctuation\">.</span><span class=\"token function\">nextTick</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span><span class=\"token string\">'argument should be string'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The snippet does an argument check and if it's not correct, it will pass the error to the callback. The API updated\nfairly recently to allow passing arguments to process.nextTick() allowing it to take any arguments passed after the\ncallback to be propagated as the arguments to the callback so you don't have to nest functions.</p>\n<p>What we're doing is passing an error back to the user but only after we have allowed the rest of the user's code to execute.\nBy using process.nextTick() we guarantee that apiCall() always runs its callback after the rest of the user's code and\nbefore the event loop is allowed to proceed. To achieve this, the JS call stack is allowed to unwind then immediately\nexecute the provided callback which allows a person to make recursive calls to process.nextTick() without reaching a\nRangeError: Maximum call stack size exceeded from v8.</p>\n<p>This philosophy can lead to some potentially problematic situations. Take this snippet for example:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> bar\n\n<span class=\"token comment\">// this has an asynchronous signature, but calls callback synchronously</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">someAsyncApiCall</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n  <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// the callback is called before `someAsyncApiCall` completes.</span>\n<span class=\"token function\">someAsyncApiCall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// since someAsyncApiCall has completed, bar hasn't been assigned any value</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bar'</span><span class=\"token punctuation\">,</span> bar<span class=\"token punctuation\">)</span> <span class=\"token comment\">// undefined</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\nbar <span class=\"token operator\">=</span> <span class=\"token number\">1</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The user defines someAsyncApiCall() to have an asynchronous signature, but it actually operates synchronously. When it\nis called, the callback provided to someAsyncApiCall() is called in the same phase of the event loop because someAsyncApiCall()\ndoesn't actually do anything asynchronously. As a result, the callback tries to reference bar even though it may not\nhave that variable in scope yet, because the script has not been able to run to completion.</p>\n<p>By placing the callback in a process.nextTick(), the script still has the ability to run to completion, allowing all\nthe variables, functions, etc., to be initialized prior to the callback being called. It also has the advantage of not\nallowing the event loop to continue. It may be useful for the user to be alerted to an error before the event loop is\nallowed to continue. Here is the previous example using process.nextTick():</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> bar\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">someAsyncApiCall</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  process<span class=\"token punctuation\">.</span><span class=\"token function\">nextTick</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">someAsyncApiCall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bar'</span><span class=\"token punctuation\">,</span> bar<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 1</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nbar <span class=\"token operator\">=</span> <span class=\"token number\">1</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Here's another real world example:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> server <span class=\"token operator\">=</span> net<span class=\"token punctuation\">.</span><span class=\"token function\">createServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token number\">8080</span><span class=\"token punctuation\">)</span>\n\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'listening'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>When only a port is passed, the port is bound immediately. So, the 'listening' callback could be called immediately.\nThe problem is that the .on('listening') callback will not have been set by that time.</p>\n<p>To get around this, the 'listening' event is queued in a nextTick() to allow the script to run to completion. This\nallows the user to set any event handlers they want.</p>\n<h1>process.nextTick() vs setImmediate()</h1>\n<p>We have two calls that are similar as far as users are concerned, but their names are confusing.</p>\n<ul>\n<li>process.nextTick() fires immediately on the same phase</li>\n<li>setImmediate() fires on the following iteration or 'tick' of the event loop</li>\n</ul>\n<p>In essence, the names should be swapped. process.nextTick() fires more immediately than setImmediate(), but this is an\nartifact of the past which is unlikely to change. Making this switch would break a large percentage of the packages on npm.\nEvery day more new modules are being added, which means every day we wait, more potential breakages occur. While they\nare confusing, the names themselves won't change.</p>\n<p>We recommend developers use setImmediate() in all cases because it's easier to reason about (and it leads to code that's\ncompatible with a wider variety of environments, like browser JS.)</p>\n<h1>Why use process.nextTick()?</h1>\n<p>There are two main reasons:</p>\n<ol>\n<li>Allow users to handle errors, cleanup any then unneeded resources, or perhaps try the request again before the event loop continues.</li>\n<li>At times it's necessary to allow a callback to run after the call stack has unwound but before the event loop continues.</li>\n</ol>\n<p>One example is to match the user's expectations. Simple example:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> server <span class=\"token operator\">=</span> net<span class=\"token punctuation\">.</span><span class=\"token function\">createServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'connection'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">conn</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token number\">8080</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'listening'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Say that listen() is run at the beginning of the event loop, but the listening callback is placed in a setImmediate().\nUnless a hostname is passed, binding to the port will happen immediately. For the event loop to proceed, it must hit the\npoll phase, which means there is a non-zero chance that a connection could have been received allowing the connection\nevent to be fired before the listening event.</p>\n<p>Another example is running a function constructor that was to, say, inherit from EventEmitter and it wanted to call an\nevent within the constructor:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> EventEmitter <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'events'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> util <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'util'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">MyEmitter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">EventEmitter</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'event'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\nutil<span class=\"token punctuation\">.</span><span class=\"token function\">inherits</span><span class=\"token punctuation\">(</span>MyEmitter<span class=\"token punctuation\">,</span> EventEmitter<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> myEmitter <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyEmitter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyEmitter<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'event'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'an event occurred!'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>You can't emit an event from the constructor immediately because the script will not have processed to the point where\nthe user assigns a callback to that event. So, within the constructor itself, you can use process.nextTick() to set a\ncallback to emit the event after the constructor has finished, which provides the expected results</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> EventEmitter <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'events'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> util <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'util'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">MyEmitter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">EventEmitter</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// use nextTick to emit the event once a handler is assigned</span>\n  process<span class=\"token punctuation\">.</span><span class=\"token function\">nextTick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'event'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nutil<span class=\"token punctuation\">.</span><span class=\"token function\">inherits</span><span class=\"token punctuation\">(</span>MyEmitter<span class=\"token punctuation\">,</span> EventEmitter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> myEmitter <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyEmitter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nmyEmitter<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'event'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'an event occurred!'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://blog.risingstack.com/node-js-at-scale-understanding-node-js-event-loop/\" target=\"_blank\">Understanding the event loop</a></li>\n<li><a href=\"https://nodejs.org/de/docs/guides/event-loop-timers-and-nexttick/\" target=\"_blank\">Event loop, timers and next tick</a></li>\n</ul>"}},"pageContext":{"slug":"/articles/nodejs-architecture-details/"}},"staticQueryHashes":["157234556"]}