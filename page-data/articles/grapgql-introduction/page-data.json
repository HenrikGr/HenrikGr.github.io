{"componentChunkName":"component---src-templates-article-page-template-js","path":"/articles/grapgql-introduction/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"GraphQL - Introduction","subtitle":"Pros & Cons using GraphQL","date":"2020-02-03","publishedBy":"Henrik Grönvall"},"excerpt":"RESTful service is one of the most popular design choices to connect client applications with servers. In REST,\neverything evolves around the idea of having…","timeToRead":6,"html":"<p>RESTful service is one of the most popular design choices to connect client applications with servers. In REST,\neverything evolves around the idea of having resources that are accessible by URLs.</p>\n<p>When designing RESTful services, you use a design pattern called CRUD (Create, Read, Update and Delete) around your\nresources and combined it with the HTTP protocol methods such as GET request, POST request, PUT and DELETE request.</p>\n<p>The format for transferring data is not opinionated with RESTful design, but most often people will use JSON for it.\nIn the end, RESTful design enables applications to communicate with each other by using plain HTTP with URLs and HTTP\nmethods.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">// a RESTful request with HTTP GET\nhttps://api.domain.com/authors/7\n\n// the response in JSON\n{\n  &quot;id&quot;: &quot;7&quot;,\n  &quot;name&quot;: &quot;Henrik Grönvall&quot;,\n  &quot;avatarUrl&quot;: &quot;https://domain.com/authors/7&quot;,\n  &quot;firstName&quot;: &quot;Henrik&quot;,\n  &quot;lastName&quot;: &quot;Grönvall&quot;\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h1>What is GraphQL?</h1>\n<p>In short, GraphQL is an open source query language created by Facebook. Before GraphQL went open source in 2015, Facebook\nused it internally for their mobile applications as an alternative to the common REST architecture.</p>\n<p>It allows requests for specific data, giving clients more control over what information is sent. This is more difficult\nwith a RESTful architecture because the backend defines what data is available for each resource on each URL, while the\nfrontend always has to request all the information in a resource, even if only a part of it is needed. This problem is\ncalled over-fetching. In worst case scenario, a client application has to read multiple resources through multiple network\nrequests and adds the need for waterfall network requests.</p>\n<p>A query language like GraphQL on the server-side and client-side lets the client decide which data it needs by making a\nsingle request to the server which leads to dramatically reduced network request.</p>\n<p>A GraphQL operation is either a query (read), mutation (write), or subscription (continuous read). Each of those\noperations is only a string that needs to be constructed according to the GraphQL query language specification.\nFortunately, GraphQL is evolving all the time, so there may be other operations in the future.</p>\n<p>Once this GraphQL operation reaches the backend application, it can be interpreted against the entire GraphQL schema there,\nand resolved with data for the frontend application. GraphQL is not opinionated about the network layer, which is often\nHTTP, nor about the payload format, which is usually JSON. It isn't opinionated about the application architecture at all.\nIt is only a query language.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">// a GraphQL query\nauthor(id: &quot;7&quot;) {\n  id\n  name\n  avatarUrl\n  articles(limit: 2) {\n    name\n    urlSlug\n  }\n}\n\n// a GraphQL query result\n{\n  &quot;data&quot;: {\n    &quot;author&quot;: {\n      &quot;id&quot;: &quot;7&quot;,\n      &quot;name&quot;: &quot;Henrik Grönvall&quot;,\n      &quot;avatarUrl&quot;: &quot;https://domain.com/authors/7&quot;,\n      &quot;articles&quot;: [\n        {\n          &quot;name&quot;: &quot;Handle complex object in JavaScript&quot;,\n          &quot;urlSlug&quot;: &quot;mediator pattern&quot;\n        },\n        {\n          &quot;name&quot;: &quot;Node.js worker threads&quot;,\n          &quot;urlSlug&quot;: &quot;nodejs-worker-threads&quot;\n        }\n      ]\n    }\n  }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>As you can see, one query can requests multiple resources (author and articles), where a RESTful architecture needs at\nleast two waterfall requests to retrieve the author entity and its articles.</p>\n<p>In addition, the query only selected the necessary fields instead of the whole entity, left out the firstName and lastName\nfrom the author entity for example.</p>\n<h1>Pros with GraphQL</h1>\n<p><b>Declarative Data Fetching</b></p>\n<p>GraphQL embraces declarative data fetching with its queries. The client selects data along with its entities with fields\nacross relationships in one query request.</p>\n<p><b>No Over-fetching</b></p>\n<p>A mobile client usually over-fetches data when there is an identical API as the web client with a RESTful API. With\nGraphQL, the mobile client can choose a different set of fields, so it can fetch only the information needed for what's\non screen.</p>\n<p><b>React, Vue, Angular, Node, Express, Koa, etc</b></p>\n<p>Facebook showcased GraphQL on a client-side application with React, it is decoupled from any frontend or backend solution.\nThe reference implementation of GraphQL is written in JavaScript, so the usage of GraphQL in Angular, Vue, Express, Hapi,\nKoa and other JavaScript libraries on the client-side and server-side is possible, and that's just the JavaScript\necosystem. GraphQL does mimic REST's programming language-agnostic interface between two entities, such as client or\nserver.</p>\n<p><b>Single Source of Truth</b></p>\n<p>The GraphQL schema is the single source of truth in GraphQL applications. It provides a central location, where all\navailable data is described. The GraphQL schema is usually defined on server-side, but clients can read (query) and\nwrite (mutation) data based on the schema.</p>\n<p><b>Schema Stitching</b></p>\n<p>Schema stitching makes it possible to create one schema out of multiple schemas. Think about a microservices architecture\nfor your backend where each microservice handles the business logic and data for a specific domain. In this case, each\nmicroservice can define its own GraphQL schema, after which you'd use schema stitching to weave them into one that is\naccessed by the client. Each microservice can have its own GraphQL endpoint, where one GraphQL API gateway consolidates\nall schemas into one global schema.</p>\n<p><b>Introspection</b></p>\n<p>A GraphQL introspection makes it possible to retrieve the GraphQL schema from a GraphQL API. Since the schema has all\nthe information about data available through the GraphQL API, it is perfect for auto-generating API documentation. It\ncan also be used to mock the GraphQL schema client-side, for testing or retrieving schemas from multiple microservices\nduring schema stitching.</p>\n<p><b>Strongly Typed</b></p>\n<p>GraphQL is a strongly typed query language because it is written in the expressive GraphQL Schema Definition Language (SDL).\nBeing strongly-typed makes GraphQL less error prone, can be validated during compile-time and can be used for supportive\nIDE/editor integrations such as auto-completion and validation.</p>\n<p><b>Versioning</b></p>\n<p>In GraphQL there are no API versions as there used to be in REST. In REST it is normal to offer multiple versions of an\nAPI (e.g. api.domain.com/v1/, api.domain.com/v2/), because the resources or the structure of the resources may change\nover time. In GraphQL it is possible to deprecate the API on a field level. Thus a client receives a deprecation warning\nwhen querying a deprecated field. After a while, the deprecated field may be removed from the schema when not many clients\nare using it anymore. This makes it possible to evolve a GraphQL API over time without the need for versioning.</p>\n<h1>Cons with GraphQL</h1>\n<p><b>Complexity</b></p>\n<p>GraphQL doesn't take away performance bottlenecks when you have to access multiple fields (authors, articles,\ncomments) in one query. Whether the request was made in a RESTful architecture or GraphQL, the varied resources and fields\nstill have to be retrieved from a data source. As a result, problems arise when a client requests too many nested fields\nat once so there must be a mechanism like maximum query depths, query complexity weighting, avoiding recursion, or\npersistent queries for stopping inefficient requests from the other side.</p>\n<p><b>Rate limiting</b></p>\n<p>Another problem is rate limiting. Whereas in REST it is simpler to say \"we allow only so many resource requests in one\nday\", it becomes difficult to make such a statement for individual GraphQL operations, because it can be everything\nbetween a cheap or expensive operation. That's where companies with public GraphQL APIs come up with their specific rate\nlimiting calculations which often boil down to the previously mentioned maximum query depths and query complexity\nweighting.</p>\n<p><b>Caching</b></p>\n<p>Implementing a simplified cache with GraphQL is more complex than implementing it in REST. In REST, resources are accessed\nwith URLs, so you can cache on a resource level because you have the resource URL as identifier. In GraphQL, this becomes\ncomplex because each query can be different, even though it operates on the same entity. You may only request just the\nname of an author in one query, but want to know the email address in the next. That's where you need a more fine-grained\ncache at field level, which can be difficult to implement. However, most of the libraries built on top of GraphQL offer\ncaching mechanisms out of the box.</p>"}},"pageContext":{"slug":"/articles/grapgql-introduction/"}},"staticQueryHashes":["4011214723"]}